[PlantUML Sequence Diagram: Test Case Flow](//www.plantuml.com/plantuml/dpng/VP91Rzim38Nl-XKy9jW2x5mWGuTktGhiK2p3xgpC9iHaIH2fjkwldrpNgfMi4U0B-Rs7HzANefWqzyx8N_OH4_PW7OfyKKrybvLkRF0xVYRuj43aW5ruPB-7UtH2YuvZJpf4Wf3q40nc3JxtTvICAO2ovOXUuJQ5VS6RsauJAks7QxGQqj3qVfFe5Ggzr_k1oPF8__nQ-0ywxh1u6BFTmerdvL9vHkNWuVQ0Gh3T6lEQ3pQVZsF11NmdVIqooMfjZebDKSq65_2JHI7SWrH9Ox-ShDhFnT6z0cVTjL1WHydBOD-UoEQZcLm84Qv30a9x09ct0-KrUUesY_rLeaB18-kR0Zw03Nt4HEcy-5VsOq5MEe-pDY-ADacDRc1wZStY0iLo5zm3hTZ7hEkAerL-A4G5QwSgDoVXGjPYKicEJbtUorF_eN51qoPMazr7eAT8LgchwHRqQOX4ajqKWdndnc-ytYxtFQRXxNPrnStjlx94XmF8X9lBei-z-mS0)

[sequence-diagram-test-case-flow](https://github.com/abhimanyu-builds/Leetcode/blob/main/Leetcode/Documentation/sequence-diagram-test-case-flow.png)

[PlantUML Class Diagram](//www.plantuml.com/plantuml/dpng/hLJ1RjGm4BtxA-RMNPLAd5UeAhGKLgA0kf4u80xJP7PZaTYHPz9IKF-ToSOfIPskG28dP-RDpBFViyzOC4XRLuQ_MzTWm1ho2fbVYmHxqmgjS-yszYV1on64IopydNKxs6B5DCfKrf7SDmG-IEcDEO9p7mZMJYXiCISsDYur-3ducuhgZQzQiTuPvuKWs5qfuBTf-fgQG4nEECczojQkQUK5P9zQqSMfkQ2jKc6Gaa1HjxIm7M89DIcnmf0he9jdvWX9GA7T_PHGcfuZ57CfeIy16mO4ZfJXpahPiS421UVvPCHoZapQ_DOM5AQ4Pl9nmI2QWLnJ35iV065dRyb1qxCSJJk2WJ9q31jjiZS0FDaGsBhHtzdDmYy3-ft0Hwnf1In1hH53ww4CkqslKbKV9XocS8vSiZk_QRKa21L3uIoXc9kKlR4Em_s6CEJbFnV_LO5ke5C2tcDmn3mzm2up753ln1LSjYwFaNDVDnZ6iMEuRbrNnGk9-l8AFbYMfNcOEc0ymsIa554eEdolE_sWl1LLOsI8YVYNc8iFbdXUzJuz27mCxqZwSua0BLmiLTIthgqfe9Ocm5wqP-4FPZfviFIpaoCWTafkmEpumpMz1QzyGTNKSFih_CVSRNr3GQMmJhv-Yy4Cmuva7ukZCx_P-rz73JT1-wS-_e_DZ-32SeEIb-FRkmjOFnxV5LgtMCQ-wgzuselkhLuzdht-HCpWmKrhXRHGfv2ADaR6tlsUHij-UtsW34GQwabUKzNVwj8sR0Q69oUduwvfF75Z2fdQvW34cFcMSzDCsdg0fXuQWtj4scqA63eyPTGbqoTczWKyW4mVlSFumvWpSaLRLxy1) visualized ([PNG](https://github.com/abhimanyu-builds/Leetcode/blob/main/Leetcode/Documentation/class-diagram.png))

[PlantUML Modular Component Diagram](//www.plantuml.com/plantuml/dpng/ZP11QiCm44NtEiMGVQvGGaEpwgAWq4tnOYeFhh6aCQCngIYzUuc9g08oP2dq__l3EoH5qILuawOnpYWOm76OEL9KgzaJ23d5E7WoPaOtuK2mEx8Gd0G3NLYc7VmOW8ytuK4mTB3VFwslJq_1gg3Ia4_eb2Ltcy4p9JrYeeU2dVcjhYaRy8gPf5pJtB-XpXUsIx0iIdr9T0-sdiU8aYsXkA-wsuOszjWlEd8idJPoU_E_NpkuMe6hlrf2qsrJGacaU-hBDxbrR8jwGzKU6j_lwCSUbMMb7oZsI_1_)

[PlantUML Strategy Registration Sequence Diagram](//www.plantuml.com/plantuml/dpng/dP9DJiD038NtSmelow8NG0ggG1GXiQW85p2farXCnf77GmcdPwB-A0r5gjZ5Vdv--fnPHKErr7c7oIIaxftKnGyEFIfs45lSoev30pNwI1F5So0RUW9HQyMvt3MkkCTWi55fyinPhpH5esPOOsMYmqNjbHgEzeVeN57a8YkfXqsBaQ0ed3jamV9k7W6ty1pO63r_q-B6pUNic0Tdo_wJTF6sap9rPSQZxN7kdqlkEQ0E9Q5MxMJLtBUyoF0WeMRjq5Z2_WRagHghQw_mH7PeCiKphcjvrcHL2_6q16fH6F_-jH0lMGIf9oj-9sVZ4MEye2KDq_aH_V6BgdI6VeaysqlndxJ8RpNPYN4U8Scox5OKjgdpFm00)

[project-visualization-diagram.drawio](https://github.com/abhimanyu-builds/Leetcode/blob/main/Leetcode/Documentation/project-visualization-diagram.png)

Description: 
Mini scalable testing framework that:
- Supports multiple problems
- Benchmarks different strategies
- Logs failures with context
- Validates flexibly (strict or relaxed)
|----------------------|--------------------------------------|--------------------------------------------------------------------------------------------|
| **Layer**            | **Component**                        | **Role / Responsibility**                                                                  |
|----------------------|--------------------------------------|--------------------------------------------------------------------------------------------|
| Orchestration        | `Program.cs`                         | Central controller that loads test cases, runs strategies, and prints results              |
| Test Harness         | `ProblemTest<TInput, TOutput>`       | Generic test runner that executes cases, validates results, logs failures, and benchmarks  |
|                      | `TestCase` record                    | Holds input, expected output, and validation mode (strict vs sum-based)                    |
| Test Case Provider   | `ITestCaseProvider<TInput, TOutput>` | Interface for generating test cases per problem                                            |
|                      | `TwoSumTestCaseProvider`             | Supplies static and randomized test cases for Two Sum                                      |
|                      | `TwoSumSortedTestCaseProvider`       | Supplies static and data-driven test cases for Two Sum Sorted                              |
| Strategy Layer       | `IProblemSolution<TInput, TOutput>`  | Interface for solving a problem with a specific algorithm                                  |
|                      | `OnOneLoopDictionarySolution`        | Fast O(n) solution for Two Sum                                                             |
|                      | `On2TwoLoopSolution`                 | Brute-force O(n²) solution for Two Sum                                                     |
|                      | `TwoSumSortedSolution`		      | Fast O(n) solution for Two Sum Sorted                                                      |
|                      | `TwoSumSortedBinarySearchSolution`   | Binary search O(nlogn) solution for Two Sum Sorted                                         |
| Strategy Registry    | `IProblemStrategy<TInput, TOutput>`  | Wraps a strategy with metadata like name                                                   |
|                      | `ProblemStrategyFactory`             | Returns all available strategies for a given problem                                       |
|                      | `TwoSumStrategies`                   | Holds the list of Two Sum strategies                                                       |
|                      | `TwoSumSortedStrategies`             | Holds the list of strategies for Two Sum II (sorted array)                                 |
|----------------------|--------------------------------------|--------------------------------------------------------------------------------------------|

How It All Connects
- Program.cs acts as the dispatcher, selecting the problem and orchestrating execution.
- Factories provide the right strategies and test cases based on the selected problem.
- Strategies implement the core logic using the Strategy Pattern.
- The test harness (ProblemTest) runs all strategies against all test cases using a template method.
- Comparison and validation logic are passed as delegates, enabling flexible behavior

Summary of the key patterns integrated into the architecture to ensure modularity, scalability, and maintainability:
1. Strategy Pattern
Used to encapsulate multiple solution approaches for each problem (e.g., Two Sum, Two Sum II). Each strategy implements a shared interface (IProblemSolution<TInput, TOutput>) and can be swapped dynamically at runtime. 
This allows for clean benchmarking, testing, and extension of new algorithms without modifying core logic.
Benefit: Promotes open/closed principle—new strategies can be added without altering existing code.

2. Factory Pattern
Factories are used to centralize the creation of test cases and strategy instances. ProblemStrategyFactory and ProblemTestCaseFactory abstract away instantiation logic, allowing the main program to retrieve problem-specific components based on an enum (ProblemType).
Benefit: Simplifies object creation and improves separation of concerns.

3. Template Method Pattern
The ProblemTest<TInput, TOutput> class defines a reusable testing workflow that accepts a strategy and a comparer. 
The structure of the test execution is fixed, while the specific logic (e.g., input types, comparison rules) is injected.
Benefit: Encourages consistent testing behavior while allowing flexibility in implementation details.

4. Adapter Pattern
The ProblemStrategy<TInput, TOutput> wrapper adapts raw solution implementations to a unified interface (IProblemStrategy). 
This enables consistent handling of strategy metadata (e.g., name, complexity) and execution logic.
Benefit: Facilitates polymorphism and clean integration of diverse solution types.

5. Enum-Based Dispatcher
The use of the ProblemType enum in Program.cs acts as a lightweight command router, directing execution flow based on the selected problem.
Benefit: Simplifies branching logic and supports future extensibility. Improves readability and centralizes control flow. 

6. Functional Composition
Test case validation and comparison logic are passed as delegates (e.g., CompareArrays, ValidateBySum). 
Benefit: Decouples behavior from structure and allows for flexible customization. Enhances testability and promotes clean separation of logic.

These patterns collectively contribute to a robust and extensible framework for solving algorithmic problems, benchmarking strategies, and maintaining clean architecture as the codebase grows.

Extending the Framework
To add a new problem:
- Create a new InputModel and TestCaseProvider
- Implement one or more strategies
- Register them in the appropriate factories
- Add a new ProblemType enum value
- Update Program.cs to dispatch it




